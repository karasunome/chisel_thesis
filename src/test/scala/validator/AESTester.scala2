package validator

import chisel3._
import chiseltest._
import org.scalatest.flatspec.AnyFlatSpec

class AESUnitTester extends AnyFlatSpec with ChiselScalatestTester {
    private val expandedKeyMemType = "Mem" // ROM or Mem or SyncReadMem works
    private val SubBytes_SCD = false
    private val InvSubBytes_SCD = false
    private val Nk = 4 // 4, 6, 8 [32-bit words] columns in cipher key
    private val unrolled = 14
    private val dir = "AES"
    private val KeyLength: Int = Nk * Params.rows
    private val Nr: Int = Nk + 6 // 10, 12, 14 rounds
    private val Nrplus1: Int = Nr + 1 // 10+1, 12+1, 14+1

  "AES Module" should "pass" in {
    test(new AES(Nk, unrolled, SubBytes_SCD, InvSubBytes_SCD, expandedKeyMemType)) { aes_i => 
        println("Starting the tests with 4 idle cycles")
        aes_i.io.AES_mode.poke(0.U) // off
        aes_i.clock.step(4) // test that things are fine in Idle state

        //val input_text = Array(0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34)
        val input_text = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

        println("Sending expanded AES key")
        // send expanded key to AES memory block
        aes_i.io.AES_mode.poke(1.U) // configure key
        for (i <- 0 until Params.Nrplus1) {
            for (j <- 0 until Params.StateLength) {
                aes_i.io.input_text(j).poke(Params.expandedKey(i)(j))
            }
            aes_i.clock.step(1)
        }

        println("Staying idle for 4 cycles") // must stop when all roundKeys were sent
        aes_i.io.AES_mode.poke(0.U)
        aes_i.clock.step(4)

        println("Starting AES cipher mode, sending plaintext")
        aes_i.io.AES_mode.poke(2.U) // cipher
        aes_i.clock.step(1)

        // send the plaintext
        for (i <- 0 until Params.StateLength) {
            aes_i.io.input_text(i).poke(input_text(i))
        }
        aes_i.clock.step(1)

        // remaining rounds
        for (i <- 0 until Nrplus1) {
            aes_i.clock.step(1)
        }

        val state_e = Array(0x7d,0xf7,0x6b,0x0c,0x1a,0xb8,0x99,0xb3,0x3e,0x42,0xf0,0x47,0xb9,0x1b,0x54,0x6f)

        for (i <- 0 until Params.StateLength)
            aes_i.io.output_text(i).expect(state_e(i))
        aes_i.io.output_valid.expect(1)
        printf("0x%x\n", aes_i.io.output_text.asUInt)

        // store cipher output
        val cipher_output = aes_i.io.output_text.peek()

        //println("Staying idle for 4 cycles")
        //aes_i.io.AES_mode.poke(0.U) // off
        //aes_i.clock.step(4)
//
        //println("Starting AES inverse cipher mode, sending ciphertext")
        //aes_i.io.AES_mode.poke(3.U) // inverse cipher
        //aes_i.clock.step(1)

        // send the ciphertext
        //for (i <- 0 until Params.StateLength) {
        //    aes_i.io.input_text(i).poke(cipher_output(i)) // same as state_e(i)
        //}
        //aes_i.clock.step(1)

        // remaining rounds
        //for (i <- 1 until Nrplus1) {
        //    aes_i.clock.step(1)
        //}
//
        //if (expandedKeyMemType == "SyncReadMem") {
        //    aes_i.clock.step(1) // InvCipher takes 1 extra clk for SyncReadMem
        //}

        //println("Inspecting inverse cipher output")
        // verify aes cipher output
        //for (i <- 0 until Params.StateLength) {
        //    aes_i.io.output_text(i).expect(input_text(i))
        //}
        //aes_i.io.output_valid.expect(true.B)
//
        //println("Staying idle for 4 cycles")
        //aes_i.clock.step(4)

// Run test with:
// sbt 'testOnly aes.AESTester'
// sbt 'testOnly aes.AESTester -- -z "using verilator"'
// sbt 'testOnly aes.AESTester -- -z "using firrtl"'
// sbt 'testOnly aes.AESTester -- -z verbose'
// sbt 'testOnly aes.AESTester -- -z vcd'
   }
  }
}

